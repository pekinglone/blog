<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kubernetes-installation]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2Fkubernetes-installation%2F</url>
    <content type="text"><![CDATA[基于Kubernetes1.10.2 0x00 前置条件 ubuntu16.04 虚拟机 shadowsocks 科学上网 本机是Win10，通过Vmvare安装好几台ubuntu16.04虚拟机，均使用root账号登陆操作，本机已经可以通过shadowsocks(简称ss)进行科学上网 虚拟机列表 主机名 ip 角色 配置 OS K8s-1 192.168.5.136 master 2U2G Ubuntu16.04 K8s-2 192.168.5.137 node 1U2G Ubuntu16.04 K8s-3 192.168.5.138 node 1U2G Ubuntu16.04 0x01 准备环境(所有虚拟机)ubuntu虚拟机配置apt源国内配置apt源为阿里云的源下载速度会快一些，(shadowsocks设置为PAC模式) 123456789101112131415$ cp -p /etc/apt/sources.list /etc/apt/sources.list.bak$ cat &lt;&lt;-EOF | sudo tee /etc/apt/sources.listdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverseEOF$ apt-get update ubuntu虚拟机配置代理进行科学上网 首先要在本机的shadowsocks上使能局域网访问(右键shadowsocks进行选择) 在ubuntu虚拟机上配置全局代理，proxyserveraddr为本机的IP地址，Windows上可使用ipconfig查看，proxyserverport为shadowsocks端口，默认为1080 将下面的内容添加到~/.profile末尾 123456789101112export proxyserveraddr=192.168.99.248export proxyserverport=1080export HTTP_PROXY="http://$proxyserveraddr:$proxyserverport/"export HTTPS_PROXY="https://$proxyserveraddr:$proxyserverport/"export FTP_PROXY="ftp://$proxyserveraddr:$proxyserverport/"export SOCKS_PROXY="socks://$proxyserveraddr:$proxyserverport/"export NO_PROXY="localhost,127.0.0.1,localaddress,.localdomain.com,10.0.0.0/8,192.168.0.0/16"export http_proxy="http://$proxyserveraddr:$proxyserverport/"export https_proxy="https://$proxyserveraddr:$proxyserverport/"export ftp_proxy="ftp://$proxyserveraddr:$proxyserverport/"export socks_proxy="socks://$proxyserveraddr:$proxyserverport/"export no_proxy="localhost,127.0.0.1,localaddress,.localdomain.com,10.0.0.0/8,192.168.0.0/16" 执行下面的命令生效proxy配置 12345678$ source ~/.profile$ cat &lt;&lt;-EOF| sudo tee /etc/apt/apt.confAcquire::http::proxy "http://$proxyserveraddr:$proxyserverport/";Acquire::https::proxy "https://$proxyserveraddr:$proxyserverport/";Acquire::ftp::proxy "ftp://$proxyserveraddr:$proxyserverport/";Acquire::socks::proxy "socks://$proxyserveraddr:$proxyserverport/";EOF 测试proxy是否可用 1$ curl www.google.com 关闭swap编辑/etc/fstab文件，注释掉引用swap的行，保存并重启后输入sudo swapoff -a即可。参考Kubelet/Kubernetes should work with Swap Enabled 0x02 安装Docker(所有虚拟机)配置好docker源版本： 17.03.0~ce-0~ubuntu-xenial 1234567891011121314$ sudo apt-get update$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 安装Docker CE123$ sudo apt-get update$ sudo apt-get install docker-ce=17.03.0~ce-0~ubuntu-xenial 详细信息参考官方文档 0x03 安装Kubernetes(所有虚拟机)配置docker镜像加速参考阿里云镜像加速器 安装kubeadm, kubelet 和 kubectl123456789$ curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -$ cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb http://apt.kubernetes.io/ kubernetes-xenial mainEOF$ apt-get update$ apt-get install -y kubelet kubeadm kubectl 提前pull镜像由于网络原因，我们需要提前拉取k8s初始化需要用到的镜像，并添加对应的k8s.gcr.io标签 123456789101112131415161718192021222324## 拉取镜像docker pull reg.qiniu.com/k8s/kube-apiserver-amd64:v1.10.2docker pull reg.qiniu.com/k8s/kube-controller-manager-amd64:v1.10.2docker pull reg.qiniu.com/k8s/kube-scheduler-amd64:v1.10.2docker pull reg.qiniu.com/k8s/kube-proxy-amd64:v1.10.2docker pull reg.qiniu.com/k8s/etcd-amd64:3.1.12docker pull reg.qiniu.com/k8s/pause-amd64:3.1## 添加Tagdocker tag reg.qiniu.com/k8s/kube-apiserver-amd64:v1.10.2 k8s.gcr.io/kube-apiserver-amd64:v1.10.2docker tag reg.qiniu.com/k8s/kube-scheduler-amd64:v1.10.2 k8s.gcr.io/kube-scheduler-amd64:v1.10.2docker tag reg.qiniu.com/k8s/kube-controller-manager-amd64:v1.10.2 k8s.gcr.io/kube-controller-manager-amd64:v1.10.2docker tag reg.qiniu.com/k8s/kube-proxy-amd64:v1.10.2 k8s.gcr.io/kube-proxy-amd64:v1.10.2docker tag reg.qiniu.com/k8s/etcd-amd64:3.1.12 k8s.gcr.io/etcd-amd64:3.1.12docker tag reg.qiniu.com/k8s/pause-amd64:3.1 k8s.gcr.io/pause-amd64:3.1## 在Kubernetes 1.10 中，增加了CoreDNS，如果使用CoreDNS(默认关闭)，则不需要下面三个镜像。docker pull reg.qiniu.com/k8s/k8s-dns-sidecar-amd64:1.14.10docker pull reg.qiniu.com/k8s/k8s-dns-kube-dns-amd64:1.14.10docker pull reg.qiniu.com/k8s/k8s-dns-dnsmasq-nanny-amd64:1.14.10docker tag reg.qiniu.com/k8s/k8s-dns-sidecar-amd64:1.14.10 k8s.gcr.io/k8s-dns-sidecar-amd64:1.14.10docker tag reg.qiniu.com/k8s/k8s-dns-kube-dns-amd64:1.14.10 k8s.gcr.io/k8s-dns-kube-dns-amd64:1.14.10docker tag reg.qiniu.com/k8s/k8s-dns-dnsmasq-nanny-amd64:1.14.10 k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64:1.14.10 需要的镜像是/etc/kubernetes/manifests/目录下查看各个yaml文件中汇总得到的 0x04 配置master节点使用kubeadm init初始化master节点1$ kubeadm init --apiserver-advertise-address=192.168.5.136 --kubernetes-version=v1.10.2 --feature-gates=CoreDNS=true --pod-network-cidr=192.168.0.0/16 init 常用主要参数： –kubernetes-version: 指定Kubenetes版本，如果不指定该参数，会从google网站下载最新的版本信息。 –pod-network-cidr: 指定pod网络的IP地址范围，它的值取决于你在下一步选择的哪个网络网络插件，比如我在本文中使用的是Calico网络，需要指定为192.168.0.0/16。 –apiserver-advertise-address: 指定master服务发布的Ip地址，如果不指定，则会自动检测网络接口，通常是内网IP。 –feature-gates=CoreDNS: 是否使用CoreDNS，值为true/false，CoreDNS插件在1.10中提升到了Beta阶段，最终会成为Kubernetes的缺省选项 最终输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960root@K8s-1:~# kubeadm init --apiserver-advertise-address=192.168.5.136 --kubernetes-version=v1.10.2 --feature-gates=CoreDNS=true --pod-network-cidr=192.168.0.0/16[init] Using Kubernetes version: v1.10.2[init] Using Authorization modes: [Node RBAC][preflight] Running pre-flight checks. [WARNING FileExisting-crictl]: crictl not found in system pathSuggestion: go get github.com/kubernetes-incubator/cri-tools/cmd/crictl[preflight] Starting the kubelet service[certificates] Generated ca certificate and key.[certificates] Generated apiserver certificate and key.[certificates] apiserver serving cert is signed for DNS names [k8s-1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.5.136][certificates] Generated apiserver-kubelet-client certificate and key.[certificates] Generated etcd/ca certificate and key.[certificates] Generated etcd/server certificate and key.[certificates] etcd/server serving cert is signed for DNS names [localhost] and IPs [127.0.0.1][certificates] Generated etcd/peer certificate and key.[certificates] etcd/peer serving cert is signed for DNS names [k8s-1] and IPs [192.168.5.136][certificates] Generated etcd/healthcheck-client certificate and key.[certificates] Generated apiserver-etcd-client certificate and key.[certificates] Generated sa key and public key.[certificates] Generated front-proxy-ca certificate and key.[certificates] Generated front-proxy-client certificate and key.[certificates] Valid certificates and keys now exist in "/etc/kubernetes/pki"[kubeconfig] Wrote KubeConfig file to disk: "/etc/kubernetes/admin.conf"[kubeconfig] Wrote KubeConfig file to disk: "/etc/kubernetes/kubelet.conf"[kubeconfig] Wrote KubeConfig file to disk: "/etc/kubernetes/controller-manager.conf"[kubeconfig] Wrote KubeConfig file to disk: "/etc/kubernetes/scheduler.conf"[controlplane] Wrote Static Pod manifest for component kube-apiserver to "/etc/kubernetes/manifests/kube-apiserver.yaml"[controlplane] Wrote Static Pod manifest for component kube-controller-manager to "/etc/kubernetes/manifests/kube-controller-manager.yaml"[controlplane] Wrote Static Pod manifest for component kube-scheduler to "/etc/kubernetes/manifests/kube-scheduler.yaml"[etcd] Wrote Static Pod manifest for a local etcd instance to "/etc/kubernetes/manifests/etcd.yaml"[init] Waiting for the kubelet to boot up the control plane as Static Pods from directory "/etc/kubernetes/manifests".[init] This might take a minute or longer if the control plane images have to be pulled.[apiclient] All control plane components are healthy after 24.001741 seconds[uploadconfig] Storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace[markmaster] Will mark node k8s-1 as master by adding a label and a taint[markmaster] Master k8s-1 tainted and labelled with key/value: node-role.kubernetes.io/master=""[bootstraptoken] Using token: dfzpd9.7xxx9kre811fgw1n[bootstraptoken] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstraptoken] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstraptoken] Configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstraptoken] Creating the "cluster-info" ConfigMap in the "kube-public" namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes master has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of machines by running the following on each nodeas root: kubeadm join 192.168.5.136:6443 --token dfzpd9.7xxx9kre811fgw1n --discovery-token-ca-cert-hash sha256:31d53cf706073f557b43e5e7acacb47dceb828ccced3c648dbfbfa4d86d74b1c kubeadm init 输出的token用于master和加入节点间的身份认证，token是机密的，需要保证它的安全，因为拥有此标记的人都可以随意向集群中添加节点。 如果想在非root用户下使用kubectl，可以执行如下命令 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 验证部署情况在浏览器中输入https://&lt;master-ip&gt;:6443来验证一下是否部署成功，我这里master-ip是192.168.5.136， 返回如下： 1234567891011121314&#123; "kind": "Status", "apiVersion": "v1", "metadata": &#123; &#125;, "status": "Failure", "message": "forbidden: User \"system:anonymous\" cannot get path \"/\"", "reason": "Forbidden", "details": &#123; &#125;, "code": 403&#125; 安装网络插件安装一个网络插件是必须的，因为你的pods之间需要彼此通信。 网络部署必须是优先于任何应用的部署，详细的网络列表可参考插件页面。 本文使用的是Calico网络，安装如下： 12# 使用国内镜像kubectl apply -f http://mirror.faasx.com/kubernetes/installation/hosted/kubeadm/1.7/calico.yaml 插件安装完成后，可以通过检查coredns pod的运行状态来判断网络插件是否正常运行 1234567891011121314root@K8s-1:~# kubectl get pods --all-namespacesNAMESPACE NAME READY STATUS RESTARTS AGEkube-system calico-etcd-nmj5j 1/1 Running 0 54mkube-system calico-kube-controllers-f9d6c4cb6-kxlb2 1/1 Running 0 54mkube-system calico-node-85nm9 2/2 Running 0 13mkube-system calico-node-vrhdl 2/2 Running 0 54mkube-system coredns-7997f8864c-2mp87 1/1 Running 0 59mkube-system coredns-7997f8864c-2vl6h 1/1 Running 0 59mkube-system etcd-k8s-1 1/1 Running 0 58mkube-system kube-apiserver-k8s-1 1/1 Running 0 58mkube-system kube-controller-manager-k8s-1 1/1 Running 0 58mkube-system kube-proxy-48p2g 1/1 Running 0 13mkube-system kube-proxy-5chhg 1/1 Running 0 59mkube-system kube-scheduler-k8s-1 1/1 Running 0 58m 等待coredns pod的状态变成Running，就可以继续添加从节点了。 0x05 添加从节点在从节点上按照前面的步骤按照好docker和kubeadm后，就可以添加从节点到主节点上了 1kubeadm join 192.168.5.136:6443 --token dfzpd9.7xxx9kre811fgw1n --discovery-token-ca-cert-hash sha256:31d53cf706073f557b43e5e7acacb47dceb828ccced3c648dbfbfa4d86d74b1c 完整输出如下： 12345678910111213141516root@K8s-2:~# kubeadm join 192.168.5.136:6443 --token dfzpd9.7xxx9kre811fgw1n --discovery-token-ca-cert-hash sha256:31d53cf706073f557b43e5e7acacb47dceb828ccced3c648dbfbfa4d86d74b1c[preflight] Running pre-flight checks. [WARNING FileExisting-crictl]: crictl not found in system pathSuggestion: go get github.com/kubernetes-incubator/cri-tools/cmd/crictl[discovery] Trying to connect to API Server "192.168.5.136:6443"[discovery] Created cluster-info discovery client, requesting info from "https://192.168.5.136:6443"[discovery] Requesting info from "https://192.168.5.136:6443" again to validate TLS against the pinned public key[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server "192.168.5.136:6443"[discovery] Successfully established connection with API Server "192.168.5.136:6443"This node has joined the cluster:* Certificate signing request was sent to master and a response was received.* The Kubelet was informed of the new secure connection details.Run 'kubectl get nodes' on the master to see this node join the cluster. 过一会儿就可以通过kubectl get nodes命令在主节点上查询到从节点了 12345root@K8s-1:~# kubectl get nodesNAME STATUS ROLES AGE VERSIONk8s-1 Ready master 1h v1.10.2k8s-2 Ready &lt;none&gt; 1m v1.10.2k8s-3 Ready &lt;none&gt; 23m v1.10.2 0x06 卸载集群想要撤销kubeadm做的事，首先要排除节点，并确保在关闭节点之前要清空节点。 在主节点上运行： 12kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsetskubectl delete node &lt;node name&gt; 然后在需要移除的节点上，重置kubeadm的安装状态： 1kubeadm reset 如果你想重新配置集群，只需运行kubeadm init或者kubeadm join并使用所需的参数即可 参考资料 Installing kubeadm Using kubeadm to Create a Cluster 使用kubeadm搭建Kubernetes(1.10.2)集群（国内环境）]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot-mybatis-docker整合使用]]></title>
    <url>%2Fblog%2F2017%2F07%2F23%2Fspring-boot-mybatis-docker%2F</url>
    <content type="text"><![CDATA[0x00 前置条件 Java Maven Docker, Docker Compose 0x01 使用maven新建Spring Boot工程按工程根目录的相对路径创建如下文件 pom.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.tomoyadeng&lt;/groupId&gt; &lt;artifactId&gt;demo-springboot-docker&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; src/main/java/demo/Application.java12345678910111213141516171819package demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class Application &#123; @RequestMapping("/") public String home() &#123; return "Get started"; &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 这样，一个简单的Spring boot的应用就创建OK。可使用mvn package编译打包为jar， 然后使用命令行java -jar target/demo-springboot-docker-1.0.0.jar直接启动 0x02 将应用docker化首先创建应用的Dockerfile src/main/docker/Dockerfile123456FROM java:8VOLUME /tmpADD demo-springboot-docker-1.0.0.jar app.jarRUN sh -c 'touch /app.jar'ENV JAVA_OPTS=""ENTRYPOINT [ "sh", "-c", "java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar" ] 然后在pom.xml中添加maven插件依赖，以支持构建docker镜像 pom.xml 12345678910111213141516&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.11&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;tomoyadeng/$&#123;project.artifactId&#125;&lt;/imageName&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt;&lt;/plugin&gt; 使用mvn install docker:build即可构建docker镜像，构建完成后，docker images可查看当前的镜像。 docker run -p 8080:8080 -t tomoyadeng/demo-springboot-docker 可以启动docker容器，此时就完成了此应用的docker化1234567891011tomoya@ubuntu:~/Code/demo-springboot-docker$ docker run -p 8080:8080 -t tomoyadeng/demo-springboot-docker . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.4.RELEASE)2017-07-23 11:53:34.894 INFO 5 --- [ main] demo.Application : Starting Application v1.0.0 on f1ff304f4b94 with PID 5 (/app.jar started by root in /)... 可使用docker stop和docker rm来停止容器运行 12345tomoya@ubuntu:~/Code/demo-springboot-docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf1ff304f4b94 tomoyadeng/demo-springboot-docker "sh -c 'java $JAVA..." About a minute ago Up About a minute 0.0.0.0:8080-&gt;8080/tcp keen_swartz$ docker stop f1ff304f4b94$ docker rm f1ff304f4b94 0x03 创建MyBatis的demo首先，在pom.xml中添加mybatis和mysql-connector的依赖 pom.xml12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 添加object类，此处省略了getter和setter src/main/java/demo/domain/User.java123456789101112131415package demo.domain;import java.io.Serializable;public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private int id; private String name; private String phoneNo; private String email;&#125; 添加mapper src/main/java/demo/mapper/UserMapper.java123456789101112package demo.mapper;import demo.domain.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;@Mapperpublic interface UserMapper &#123; @Select("select * from tbl_user where name = #&#123;name&#125;") User findByName(@Param("name") String name);&#125; 修改Application.java，添加查询数据库的操作 src/main/java/demo/Application.java123456789101112131415161718192021222324252627282930313233343536package demo;import demo.domain.User;import demo.mapper.UserMapper;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import static org.springframework.web.bind.annotation.RequestMethod.GET;@SpringBootApplication@RestControllerpublic class Application &#123; final private UserMapper userMapper; public Application(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @RequestMapping("/") public String home() &#123; return "Get started"; &#125; @RequestMapping(value = "/user", method = GET) public String getUserByName(@RequestParam("name") String name) &#123; User user = this.userMapper.findByName(name); return user == null ? "No such user!" : user.toString(); &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 添加application.yml配置文件 src/main/resources/application.yml1234567891011121314151617# application.ymlspring: datasource: url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&amp;useSSL=false driverClassName: com.mysql.cj.jdbc.Driver username: root password: 123456 schema: classpath:schema.sql---spring: profiles: container datasource: url: jdbc:mysql://$&#123;DATABASE_HOST&#125;:$&#123;DATABASE_PORT&#125;/$&#123;DATABASE_NAME&#125;?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&amp;useSSL=false username: $&#123;DATABASE_USER&#125; password: $&#123;DATABASE_PASSWORD&#125; schema: classpath:schema.sql initialize: true 附：schema.sql src/main/resources/schema.sql12345drop table if exists tbl_user;create table tbl_user(id int primary key auto_increment,name varchar(32),phoneNo varchar(16), email varchar(32));insert into tbl_user(name, phoneNo, email) values ('dave', '13012345678', 'dave@tomoyadeng.com'); 修改Dockerfile，主要是修改ENTRYPOINT src/main/docker/Dockerfile123456FROM java:8VOLUME /tmpADD demo-springboot-docker-1.0.0.jar app.jarRUN sh -c 'touch /app.jar'ENV JAVA_OPTS=""ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-Dspring.profiles.active=container","-jar","/app.jar"] 0x04 手动启动docker应用首先，我们需要先启动一个mysql的容器，执行下面命令即可 1234567docker run -d \ --name mybatis-mysql \ -e MYSQL_ROOT_PASSWORD=123456 \ -e MYSQL_DATABASE=mybatis \ -e MYSQL_USER=dbuser \ -e MYSQL_PASSWORD=123456 \ mysql:latest 启动完成后，可用docker ps查看，也可以通过执行下面命令连接到mysql 12docker run -it --link mybatis-mysql:mysql --rm mysql sh \ -c 'exec mysql -h"$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" -uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"' 然后，启动应用容器并连接到mysql 12345678910docker run -d -t \ --name demo-springboot-docker \ --link mybatis-mysql:mysql \ -p 8088:8080 \ -e DATABASE_HOST=mybatis-mysql \ -e DATABASE_PORT=3306 \ -e DATABASE_NAME=mybatis \ -e DATABASE_USER=root \ -e DATABASE_PASSWORD=123456 \ tomoyadeng/demo-springboot-docker 启动完成后，使用docker ps查看，或者直接访问url测试 1curl http://localhost:8088/user?name=dave 0x05 使用docker-compose启动在项目根路径下增加docker-compose的配置文件 docker-compose.yml 12345678910111213141516171819202122version: '3.3'services: mybatis-mysql: image: mysql:latest environment: - MYSQL_ROOT_PASSWORD=123456 - MYSQL_DATABASE=mybatis - MYSQL_USER=dbuser - MYSQL_PASSWORD=123456 demo-springboot-docker: image: tomoyadeng/demo-springboot-docker depends_on: - mybatis-mysql ports: - 8088:8080 environment: - DATABASE_HOST=mybatis-mysql - DATABASE_USER=root - DATABASE_PASSWORD=123456 - DATABASE_NAME=mybatis - DATABASE_PORT=3306 启动前，先将之前手动启动的容器停掉 1234docker stop demo-springboot-dockerdocker stop mybatis-mysqldocker rm demo-springboot-dockerdocker rm mybatis-mysql 然后直接使用命令启动 1docker-compose up]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
</search>
